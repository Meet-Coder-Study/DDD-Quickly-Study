# 목차
- [5장 모델 무결성 보존](#5-----------)
  * [분할된 컨텍스트](#--------)
  * [지속적인 통합](#-------)
  * [컨텍스트 맵](#------)
  * [컨텍스트 맵을 만드는데 사용할 수 있는 패턴](#------------------------)
    + [1. 공유 커널](#1------)
    + [2. 고객-공급자](#2-------)
    + [3. 변질 방지 레이어](#3----------)
    + [4. 분할 방식](#4------)
    + [5. 오픈 호스트 서비스](#5-----------)
    + [6. 증류](#6---)
- [6장 오늘날 DDD는 중요하다](#6------ddd------)


# 5장 모델 무결성 보존

**도메인 주도 개발 관점에서 여러 팀의 공동 작업이 필요한 대규모 프로젝트의 경우 어떻게 해야 하는가?**

각 팀에게 서로 다른 모델을 할당하여 작업하게 되는데, 서로 다른 팀의 도메인을 제대로 이해하지 못하고 있으면 다른 팀의 코드에 일부 기능을 추가하는 것 만으로도 모델에 변화를 주어 애플리케이션 시스템의 기능성을 망가뜨릴 수 있다.

**모델의 무결성을 유지하는 방법 (변하지 않는 용어, 모순 없는 일관성을 유지하는 법)**

1. 기업 도메인 전체를 다루는 하나의 모델을 유지한다.

    허나 대규모 프로젝트에서 기업 도메인 전체를 다루는 하나의 모델을 유지하는 것은 너무나도 어렵다 

    → 결국엔 쪼개진다..

2. 각 모델들이 각각 지켜야 하는 계약들을 준수하여 작성한다.

    이 때 각 모델은 경계가 명확해야 하며, 모델들 간의 관계는 정밀하게 맺어져야 한다.

    ![1](https://user-images.githubusercontent.com/40685291/129468610-a2540f52-8760-4b7a-8857-22e84c1b81e2.png)


## 분할된 컨텍스트

각 모델별로 컨텍스트의 범위를 명시적으로 구분하며 이를 잘 지켜야 한다~

- 모델은 각각 컨텍스트를 하나씩 가지는데, 컨텍스트란 모델 안에서 사용된 용어들이 특정한 의미를 가지는 것을 보장할 수 있도록 적용되는 조건들의 집합이다.
- 한 모델 안에서 컨텍스트는 암묵저이며 우리는 그 컨텍스트를 정의할 필요가 없지만 대규모 시스템 개발시에는 각 모델에 대해서 컨텍스트를 정의해야만 한다.
- 대규모 시스템에서는 여러 모델이 유기적으로 동작해야 하는데 각 모델에 어떤 컨텍스트를 적용하면 안되는지 결정하기 명확하지 않은 경우가 자주 일어나며 팀 멤버간 의사소통이 혼란스러워진다.
- **하나의 모델은 하나의 팀에 합당하기에 적합할 만큼 작아야 한다.**
- 모델의 범위를 어떻게 정의할 것인가?
    ```
    1. 모델의 범위를 정함
    2. 컨텍스트 간 경계 설정
    3. 모델이 통합된 상태를 최대한 유지
    ```
- 명시적으로 모델에 적용할 수 있는 컨텍스트를 정의해야 한다.
    ```
    예시) 코드 기반에 선언, 데이터베이스 스킴에 선언, ...
    ```
- 분할된 컨텍스트와 모듈을 혼동할수도 있는데, 분할된 컨텍스트란 모듈을 포함하는 개념이다.
- 모델이 분할되어 있지 않고 하나의 모델을 두고 일하게 되면 일부 기능을 수정할 때마다 기존 기능을 깨뜨릴 수 있음을 인지해야 하지만, 분할된 여러 모델을 사용하고 그 경계 내에서 모델의 순수성, 일관성 및 통일성을 지키기 위해 노력하게 되면 손쉽게 리팩토링 등의 수정을 할 수 있다.

## 지속적인 통합

![2](https://user-images.githubusercontent.com/40685291/129468598-6b20b756-2446-4780-8ea2-52f0c67ca34c.png)

- 동일한 컨텍스트에서 여러 사람이 일할 때, 각 모델이 단편화 될 경향이 높아진다.
- 그렇다고 컨텍스트를 여러개로 쪼개게 되면 통합과 응집성의 가치가 보장되는 적절한 수준을 지나쳐 버린다.
- 모델은 초기부터 충분하게 완벽히 정의될 수 없기에
- 새로운 구성 요소가 기존 모델에 조화롭게 추가 적용되고, 코드로 올바르게 구현되도록 보장할 수 있는 **통합된 프로세스**가 필요하다.
    ```
    ex) 빌드 프로세스, 모델을 검증할 수 있는 자동화된 테스트
    ```

## 컨텍스트 맵

여러 모델의 전체 개요에 대한 이미지를 어떻게 잡을 것인가?

![3](https://user-images.githubusercontent.com/40685291/129468600-75cf3347-c3c2-43f5-8875-63851c2ea64e.png)

- 컨텍스트 맵은 서로 다른 분할된 컨텍스트들과 그들의 관계에 대한 개요를 표현한 문서이다.
- 개별 조각은 함께 조립되어 전체 시스템을 이루어 동작하게 될 것인데, 컨텍스트가 명확하게 정의되어 있지 않다면 서로 다른 모델에 중복된 부분이 있을 수 있고, 통합하여 동작시킬 때 정상적으로 동작하지 않을 수도 있다.
- 각각의 분할된 컨텍스트는 고유한 이름이 있어야 의사소통이 원활해진다. 명명 규칙을 정하고 이를 사용해서 각 모델이 속한 컨텍스트를 가리키자. 이 이름은 유비쿼터스 언어로 되어있어야 한다.

## 컨텍스트 맵을 만드는데 사용할 수 있는 패턴

![4](https://user-images.githubusercontent.com/40685291/129468601-c9a6c478-4e95-4b4f-8e36-8f56daf42c0d.png)

- 모델과 설계를 건강하게 유지하면서 서브 시스템들이 함께 동작하도록 통합하는 방법
- 컨텍스트간의 상호작용 수준이 높다면? → **공유 커널**, **고객-공급자** 패턴
- 독립성을 높이고 관계를 분리하고 싶다면 → **분할 방식** 패턴
- 시스템과 외부의 어떤 것과의 상호작용을 다뤄야 한다면? → **오픈 호스트 서비스**, **변질 방지 레이어** 패턴

### 1. 공유 커널

- 하나의 팀이 너무 큰 경우 지속적으로 모델들을 통합하는 오버헤드가 너무 크다고 느낄 수 있다.
- 분할된 컨텍스트 기준으로 팀을 나누게 될 때 어플리케이션에서 서로 밀접하게 관련되어 있는 팀은 공유해야 하는 부분을 가리키는 공유 커널을 만들 수 있다.
- 공유커널은 명시적으로 공유된 부분으로, 다른 팀과 협의하지 않고 변경해서는 안 되는 공유된 요소가 되는 것
- 이 부분에는 모델, 코드, 데이터베이스 설계 등이 포함된다.

### 2. 고객-공급자

- 하나의 서브 시스템이 하나의 서브 시스템에 완전히 의존하는 관계의 경우
    - 컨텍스트는 별도 존재
    - 한쪽의 처리 결과는 다른쪽에 반영됨
    - 그러나 공유 커널이 없음. 개념적으로 맞지 않거나 기술적으로 구현 불가능함

    이 경우 두 서브 시스템은 고객-공급자 관계를 갖는다.

- 예를 들어 e-shopping 팀, 리포팅 팀이 있다고 할 때 리포팅 팀은 고객의 역할을, e-shopping 팀은 공급자의 역할을 하여 의사를 결정한다.
    - 두 팀간 명확한 고객-공급자 관계를 구축
    - 계획 단계에서 고객 팀은 공급자팀에 대해서 고객 역할을 수행하고
    - 고객의 요구사항을 위한 협상과 예산 수립 업무를 진행하여
    - 모든 사람이 이해할 수 이쓴 합의점과 일정을 도출해야 한다.

**순응**
- 고객-공급자 관계에서 공급자팀이 고객팀을 돕지 않는 경우를 대비하여 고객팀은 두 컨텍스트를 연결하기 위한 번역 계층을 구현해야 한다.
- 고객이 공급자팀의 모델을 사용하는데 이 모델이 잘 된 모델이라면 이것이 순응을 위한 경우이다.
- 공유 커널과 유사하지만 차이점은 고객팀은 커널에 변경을 가할 수 없다는 점이다.
- 공급자팀이 제공하는 컴포넌트를 고객팀인 우리가 만든 것인 양 다루면서 해당 컴포넌트가 담긴 모델을 만들어 나가는 방식
- 어댑터를 이용하거나 두 모델 사이에 번역을 하는 방법이 있다.

### 3. 변질 방지 레이어

![5](https://user-images.githubusercontent.com/40685291/129468602-4e5980e7-76ae-4a63-b10f-1a0aa244eccd.png)

- 도메인 모델과 레거시 모델을 통합시키려면 어떻게 해야 하는가?
- 클라이언트 시스템과 외부 시스템은 (1) 네트워크 연결이나 (2) 데이터베이스를 통해 상호작용을 하는데
    - (1)의 경우 클라이언트가외부 시스템의 인터페이스에 밀착해야 하고
    - (2)의 경우 원시 데이터는 모델에 대한 어떤 의미있는 구조를 포함하고 있는 등의 정보를 포함하고 있지 않다.
- 외부 모델이 클라이언트 모델을 변경되지 않도록 독립적인 구조를 갖게끔 그 사이에 변질 방지 레이어를 두는 방법이 있다.
    - 우리 모델과 유사하게 동작하지만, 외부 모델에게 클라이언트 언어가 아닌 외부 언어로 이야기한다.
    - 서로 다른 도메인과 언어 간 양방향 번역자
- 구현법?
    - Facade, Adapter, Translator
    - 클라이언트 모델 관점에서의 서비스로 취급
    - 레이어 안의 각 서비스는 대응되는 퍼사드가 존재
    - 어댑터는 외부 시스템의 행위를 감싼다.
    - 객체와 데이터 변환은 트랜스레이터가 수행한다.

### 4. 분할 방식

- 공유커널, 고객-공급자, 변질 방지 레이어 패턴은 모델과 설계를 유지하면서 서브 시스템들이 함께 동작하도록 통합하는 방식이다.
- 그러나 어떤 요구사항을 구현할 때 모델이라는 관점에서 공통부분이 없는 두 개 이상의 집합으로 나눌 수 있다면 분할하는 것이 좋을 수 있다.
- 분할하게 되면 구현에 사용하는 기술을 선택할 때 자유로워진다는 장점이 있다.
- 분할 방식으로 진행할 때 혹여 통합된 시스템으로 돌아가지 않을 것이라는 확신이 필요하다.

### 5. 오픈 호스트 서비스

- 하나의 서브 시스템이 다른 많은 서브 시스템과 통합되어야 할 때 각 서브 시스템을 위한 번역기를 커스터마이징 하게 되면 일이 너무 커진다.
- 외부 시스템을 서비스의 제공자로 바라보는 것이 해결법이다.
- 자신의 시스템에 접근할 수 있는 프로토콜을 서비스의 집합으로 정의하여 오픈하라.

### 6. 증류

- 대규모 프로젝트에서 핵심 개념과 일반적인 개념을 분리해야 한다.
    - 도메인의 규모가 크다면 아무리 재정의하고 추상화 작업을 거치고 리팩토링을 거친다고 하더라도 거대할 것이다. 이 때 증류 작업을 통해서 핵심과 서브 모듈을 분리해내야 한다.

- 시스템의 핵심 도메인은 우리가 시스템을 어떻게 보느냐에 따라 다르다. 애플리케이션에 맞게 핵심을 올바르게 파악해야 한다.
    - 예를 들어 라우팅 시스템은 경로 및 경로간의 의존 관계가 핵심으로 경로가 핵심 도메인이 되지만, 항공관제 시스템에서 항로는 서브 도메인이다.

- 프로젝트의 핵심이 아닌 응집도 높은 서브 도메인을 식별해서 분리시키는 작업이 중요하다.
- 일반적인 서브 도메인을 구현하는 방법으로는 아래와 같은 방법이 있다.
    - 상용 솔루션: 만들어진 것을 가져다 쓰자~
    - 아웃 소싱: 외주로 맡기자~
    - 기존 모델: 기존에 만들어진 모델을 일부 수정해 사용하자
    - 사내 개발: 이 방식은 높은 수준의 통합을 이룰 수 있다는 장점이 있지만 계속 유지보수 해야 한다.

# 6장 오늘날 DDD는 중요하다

그렇답니다..
