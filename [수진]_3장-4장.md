# 3장. 모델 주도 설계

모델링이 완료되면 모델을 기반으로 코드를 구현한다. 그를 위해 모델은 아래 2가지 목적을 달성할 수 있어야 한다.

1. 도메인의 핵심 개념을 담고 소프트웨어 개발에 관여하는 모든 사람들이 공통으로 사용할 수 있는 유비쿼터스 언어로서의 역할
2. 도메인을 정확하게 반영하고 쉽게 구현될 수 있어야 한다

→ 모델을 도출하는 과정에 소프트웨어 개발자가 참여하고, 소프트웨어 개발자가 코드를 설계하고 구현하는 과정에서 도메인 전문가, 소프트웨어 분석가가 개입해야 한다

⇒ 모델링, 설계&구현의 과정을 밀접하게 관련시킬 것

- 코드의 변경은 모델의 변경이다. 코드를 작성하는 사람은 모델을 아주 잘 알고 있어야 하며, 모델의 무결성에 대해 책임감을 느껴야 한다!

**모델 주도 설계 vs 개발 툴과 언어**

- 도메인 주도 설계는 소프트웨어 개발을 위해 소프트웨어 전문가와 도메인 전문가가 만나 핵심 도메인을 모델링하는 설계 기법
- 개발 툴: 도출한 모델을 코드로 구현하는 도구, 방법론 ex. 객체지향 프로그래밍(OOP), 절차지형 프로그램
- 언어: 소프트웨어를 작성하기 위한 언어

→ 구현과 모델을 밀접하게 연관시키려면 객체지향 프로그래밍처럼 모델링 패러다임을 지원하는 개발 툴이나 언어가 적합하다. 객체의 클래스, 클래스들의 연관, 인스턴스, 서로 주고 받는 메시지를 이용해 모델 객체와 그들 간의 관계를 프로그래밍 영역으로 직접 매핑할 수 있다.

**분석 모델**

분석과 코드 설계를 분리해서 서로 다른 사람이 작업하도록 하는 기법

분석 측면에서 올바른 모델링이 될지라도 소프트웨어 설계를 염두에 두지 않았기 때문에 분석 모델에 내재된 결함이나 도메인 자체의 복잡성을 미리 알 수 없다. 객체 영속성에 문제를 지녔거나, 코드로 변환하기 어려울 수 있고, 분석 과정에서 도출된 도메인의 지식이 모델에 응축되어 개발자는 그를 자의적으로 해석하게 된다. 그 결과 모델과 코드 사이의 매핑 관계가 사라진다.

### 모델 주도 설계를 위한 블록

스마트 UI, 서비스, 엔티티, 값 객체, 계층형 아키텍처, 리파지토리, 집합, 팩토리. 다음의 패턴들은 도메인 주도 설계 관점에서 객체 모델링 및 소프트웨어 설계의 핵심 요소들을 보여준다.

### 계층형 아키텍처

소프트웨어 어플리케이션은 도메인 뿐만 아니라 DB 접근, 파일/네트워크 접근, 사용자 인터페이스 등과 관련된 인프라스트럭처, 소프트웨어를 지원하는 제반 환경 코드들을 포함한다.

→ 각 코드들이 도메인과 엉켜있다면 읽고 이해하기 어렵고 유지보수하기 힘들다.

⇒ 따라서 '레이어'로 분할해야한다. 레이어 내부에서 설계를 수행해서 응집도 높고 자신의 하위 레이어에만 의존하도록 만든다. 도메인은 도메인 모델 자체를 표현하는 것에만 집중하도록 하여 풍부하고 명확하게 만든다.

**표준 아키텍처**

상위 레이어에 대한 의존을 낮추려면 표준적인 아키텍처 패턴을 따라야 한다.

- 사용자 인터페이스(Presentation Layer): 사용자에게 정보를 보여주고 사용자의 명령을 해석하는 책임을 진다
- 애플리케이션 레이어: 애플리케이션 활동을 조율하는 얇은 레이어. 업무 로직을 포함하지 않는다. 비지니스 객체의 상태를 보관하지 않지만 애플리케이션 작업의 처리 상태는 보관한다
- 도메인 레이어: 도메인 정보를 포함. 업무 소프트웨어의 심장에 해당. 비지니스 객체의 상태를 포함한다. 비지니스 객체와 이 객체의 상태 정보 중 가능한 부분의 영속성에 대한 책임은 인프라스트럭처 레이어로 위임된다
- 인프라스트럭처 레이어: 다른 레이어 모두를 지원하는 라이브러리로 동작한다. 레이어 간의 통신을 제공하고 비지니스 객체의 영속성을 구현하고 사용자 인터페이스 레이어의 라이브러리를 포함한다

### 엔티티

소프트웨어가 여러 상태를 거치는 동안에도 동일한 값을 유지하는 식별자를 지니는 유형의 객체

시스템의 전 생명주기 혹은 그 이상으로 확장될 수 있는 연속성과 식별성이 중요하다

식별자는 객체의 속성, 속성들의 조합, 특별히 만들어진 식별자 속성 심지어 행위일 수 있다

ex. 주민등록번호, 계좌 번호, 자동 생성 ID, 공항 코드

식별자가 같은 두 객체는 같다고 간주한다

객체가 일반 속성이 아닌 식별자로 구별된다면 모델의 해당 객체 정의에 이 식별자가 반영되어야 한다

이 때, 클래스의 정의를 단순하게 유지하고 생명주기의 연속성과 식별자에 초점을 맞추어야 한다

각 객체의 형태나 이력에 관계없이 객체 자체를 구별하는 수단을 정의해야 한다, equals에 해당하는 오퍼레이션을 정의해야한다.

### 값 객체

모든 객체를 엔티티로 만들면 각 인스턴스를 추적할 수 있어야하므로 비용이 크다.

도메인의 어떤 측면을 표현하는 데 사용되지만 식별자가 필요하지 않고, 그 객체가 가지는 속성에만 관심이 있는 경우 이것을 값 객체라고 부른다.

식별자가 없는 값 객체는 공유될 수 있으며, 값 객체는 불변이어야 한다.

값 객체는 다른 값 객체 혹은 엔티티의 참조를 가질 수 있다.

### 서비스

유비쿼터스 언어를 정의할 때 도메인의 핵심 개념이 나타나면 명사는 객체로, 동사는 객체의 행위로 매핑

모델을 구성하는 주요 객체를 정의할 때 어떤 도메인은 객체로 쉽게 매핑되지 않는 경우가 있다

ex. 여러 객체에 걸쳐 동작하는 경우: 한 계좌에서 다른 계좌로 돈을 보내는 경우

→ 행위를 아무 도메인 객체에 포함시키는 것 혹은 기능 자체만 때어서 정의하는 것은 객체지향 원칙에 벗어난다

→ 이런 유형의 행위를 위한 가장 좋은 해결 방법은 서비스로 정의하는 것

**서비스**

- 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값 객체에 속할 수 없는 도메인의 개념을 나타낸다
- 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다
- 오퍼레이션은 상태를 저장하지 않는다

→ 서비스 객체 자신이 아닌 다른 값 객체, 엔티티를 대상으로 비지니스 로직을 수행한다

→ 도메인에서 주요 처리나 변경을 수행하는 작업을 발견했는데, 엔티티나 값 객체의 역할이 아니라면 서비스로 독립적인 인터페이스 오퍼레이션 추가. 인터페이스는 유비쿼터스 언어의 일부로 만든다

→ 서비스는 애플리케이션 레이어, 도메인 레이어, 인프라 스트럭처 레이어에 속할 수 있다?

### 모듈

시스템의 규모와 복잡성이 커지면 전체 모델을 이해하기 어려워진다

→ 작은 부분들 간의 관계나 상호작용을 고려해서 조직화, 구조화 = 모듈 생성

⇒ 모듈 간의 관계를 중심으로 전체 시스템을 이해하기 쉬워진다

⇒ 높은 응집도와 낮은 결합도로 코드 품질이 좋아진다

**통신 응집도**

모듈의 일부가 같은 데이터를 다룰 때 얻을 수 있음

**기능 응집도**

모듈의 모든 부분이 잘 정의된 임무를 함께 수행하고 있을 때 얻어짐

**좋은 모듈 설계를 위해서**

- 시스템을 잘 설명할 수 있고 기능적, 논리적으로 응집도를 보장하는 요소로 구성한다
- 모듈은 다른 모듈이 접근할 수 있는 인터페이스를 제공하는 것이 좋다
- 모듈에 이름을 부여하라. 유비쿼터스 언어를 구성할 것이다.

→ 모듈의 역할이 결정되고 나면 주로 내부의 변경이 많이 일어날 가능성이 높다

### 집합(Aggregate)

도메인 생명 주기를 관리하기 위한 패턴이며 객체의 소유권과 경계를 정의하는 데 사용되는 패턴

도메인 객체들 사이에 다양한 연관 관계가 있고, 모델에서 추적 가능한 각각의 관계가 있을 때 소프트웨어 적으로 구현할 메커니즘이 존재해야 한다.

데이터 무결성을 DB 수준이 아닌 모델 수준에서 해결해야 하는 경우가 있고, 불변식을 유지할 수 있어야 한다

→ 객체들 간의 관계를 제거 혹은 단순화 할 것!

- 모델의 핵심 사항이 아니면 그 관계를 제거한다
- 다수성의 숫자는 제약사항을 추가하여 감소시킨다?
- 많은 경우 양방향은 단방향 관계로 대체될 수 있다

**집합(Aggregate)**

관계가 복잡한 모델에서 객체가 일관성을 유지하도록 보장하기위해 집합을 사용

집합은 데이터를 변경할 때 하나의 단위로 간주되는 관련된 객체들의 집합

집합은 하나의 root 엔티티를 지니고 집합 내부의 다른 객체는 root를 통해서만 접근 가능

→ root에게 집합에 속한 다른 객체를 변경, 수정. root가 집합의 오퍼레이션을 제어하므로 불변식을 책임진다.

→ 하나의 객체의 외부와 내부를 가르는 경계를 정해 구분한다. 

root 엔티티는 전역 식별자를 지니며 내부에 다른 엔티티가 있다면 이러한 엔티티의 식별자는 지역적이다(집합 내부에서만 의미를 가진다)

### 팩토리

도메인 생명 주기를 관리하기 위한 패턴이며 객체의 생성을 도와주기 위한 설계 패턴

### 리파지토리

도메인 생명 주기를 관리하기 위한 패턴이며 객체의 저장을 도와주기 위한 설계 패턴

# 4장. 깊은 통찰을 향한 리팩터링

### 지속적인 리팩터링

리팩터링은 두 가지 맥락에서 진행되어야 한다.

1. 기술적인 맥락: 코드 질의 개선. 조직화, 구조화된 다양한 패턴이 존재. 학습과 기계적으로 진행 가능.
2. 도메인 모델 정련, 개선: 도메인 전문가, 개발자의 깊은 생각, 통찰, 경험, 수정을 통해 달성 가능.

→ 초기 모델은 깊이가 얕을 수 밖에 없고 리팩터링은 필연적으로 일어난다

⇒ 유연한 설계가 필요하다

⇒ 도메인 전문가와 개발자의 밀접한 협업, 리팩터링을 통해 본질적이고 정교한 도메인 모델을 만들 수 있다

### 핵심 개념 드러내기

리팩터링은 작은 단계로 연속적으로 일어난다. 소규모의 변경이 큰 차이를 초래하는 경우를 "도약"이라 지칭.

다듬어지 않은 피상적인 모델 → 새로운 개념 추가 및 추상화 → 개선

**도약을 위한 방법**

도약을 위해서는 암시적 개념을 명시적으로 만들 필요가 있다 = 도메인의 개선 = 모델, 설계에 반영하라

1. 유비쿼터스 언어로 변환되지 않은 초기 단계의 암시적 개념에서 핵심 개념 도출
2. 이해하기 어려운 계산 경로를 만드는 관계, 프로시저 등 불필요하게 비대해진 객체를 살펴보고 숨겨진 핵심 개념 도출
3. 지식 체계가 모순적으로 보이는 곳은 사실 관점의 차이나 정확한 설명이 부족한 탓일 가능성이 높다 → 개념 정제
4. 해당 도메인의 문헌 활용
5. 제약 조건, 처리, 명세 개념 활용

**제약 조건(constraint)**

불변식을 표현하는 방법

제약 사항을 별도의 메서드로 분리하여 리팩터링할 수 있다

```java
public class Bookshelf {
	private int capacity = 20;
	private Collection content;
	
	public void add(Book book) {
		if(isSpaceAvailable()) {
			content.add(book);		
		} else {
			throw new IllegableOperationException("The bookshelf has reached its limit.");
		}
	}

	private boolean isSpaceAvailable() {
		return content.size() < capacity;
	}
}
```

**처리(process)**

절차적으로 표현되지 않도록 주의

프로세스에 쓸 객체를 선택하여 그 객체에 해당 행위를 추가

프로세스를 구현하는 최고의 방법은 서비스 사용

프로세스를 처리하는 방법이 여럿이라면 전략 패턴 활용(알고리즘 캡슐화)

유비쿼터스 언어가 처리 절차 각각에 대해 상세하게 언급하고 있다면 명시적 구현을 시작할 때

**명세(specification)**

객체가 특정 기준을 만족하는지 여부를 확인하는 목적

도메인 계층은 엔티티와 값 객체에 적용될 비지니스 규칙을 담고, 이러한 규칙은 보통 적용되어야 할 객체에 포함(주로 boolean을 리턴하는 연속된 논리 연산, ex. isEligible())

비지니스 규칙이 크고 복잡해지면 해당 객체가 원래 목적에 부합하지 않을만큼 확대대기도 한다

→ 리팩토링 필요한 시점

- 비지니스 규칙을 어플리케이션 계층으로 옮기지 않도록 주의, 도메인 계층 내에 유지되어야 함
- 비지니스 규칙은 해당 객체의 명세가 되는 자체적인 객체 속에 캡슐화
- 비지니스 규칙이 명세화된 하나의 객체 내에 구성되지 않으면 코드가 밖으로 퍼져나가고 일관성이 떨어짐

```java
Customer customer = customerRepository.findCustomer(customerIdentity);
...
Specification customerEligibleForRefund = new Specification(
			new CustoperPaidHisDebitsInThePast(),
			new CustomerHasNoOutstandingBalances());
if(customerEligibleForRefund.isSatisfiedBy(customer)) {
	refundService.issueRefundTo(customer);
}
```