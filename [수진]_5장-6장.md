# 5장. 모델 무결성 보존

여러 팀의 공동 작업이 필요한 대규모 프로젝트의 경우, 도메인의 무결성(=내부 일관성, 통일성)을 유지하기 어렵다. 각 팀은 독립적인 부서와 관리체계에 속하고 개발 기간 동안 독립성과 상호작용이 공존하기 때문.

기업 규모의 대형 프로젝트 전체를 커버하는 통합된 모델을 유지하기는 너무 어려운 일이다. 이 경우 결국 쪼개질 하나의 큰 모델을 유지하려 노력하는 대신, 의도적으로 이것을 여러 개의 모델로 분할하는 접근법을 취할 수 있다. 모델들이 각 지켜야하는 계약들을 준수하는 한 잘 통합될 것이다.

### 분할된 컨텍스트

모델의 컨텍스트: 모델 안에서 사용된 용어들이 특정한 의미를 가지는 것을 보장할 수 있도록 적용되는 조건들의 집합

→ 모델은 각각의 컨텍스트가 하나씩 존재

→ 대규모 기업 시스템을 개발할 때는 거대한 전체 모델을 작은 것으로 분할(정확한 기준이 존재하는 것은 아님. 상호 관련되고 자연스러운 개념을 형성하는 요소를 하나의 모델에!)

→ 각각의 모델의 범위를 정하고 컨텍스트의 경계를 명시적으로(물리적으로!) 정의

⇒ 큰 모델을 가지고 독립적인 팀들이 개발하면 모델의 순수성을 유지하기 어렵지만, 작은 부분으로 국한시키면 모델의 무결성 유지에 유리하다

→ 추가적으로 모델을 분리하기 위해서 모델 간 경계와 관계를 정의하고, 설계, 모델끼리의 번역 작업이 필요

**분할된 컨텍스트 ≠ 모듈**

- 컨텍스트는 발전하는 모델에 담길 논리적인 프레임을 제공
- 모듈은 모델의 구성요소를 조직화하기 위해 사용

예시) 쇼핑몰 도메인

→ 쇼핑몰(전자상거래 전반) 애플리케이션, 리포팅(주문 내역 메일 전송, 추천 리포트 생성 등)으로 모델 분리

→ 주문이 들어오면 메시징 시스템을 이용해 구매 정보를 창고 쪽으로 값 객체를 비동기로 보낼 수 있다

→ 두 모델 분리하여 개발 가능, 둘 사이의 인터페이스를 확실히 설계할 필요

### 지속적인 통합

- 여러 사람이 동일한 컨텍스트 안에서 일하고 있을 때, 모델이 단편화(여기저기 분산되는) 될 경향이 높아진다

    But, 너무 작은 컨텍스트로 분할하는 것도 통합과 응집성의 가치를 제공하는 적절한 수준을 넘길 수 있다

- 한 팀이 분할된 컨텍스트에서 일할 때도 에러의 소지

    → 원활한 의사소통 필요

→ 모델은 초기 버전에서 꾸준히 개선된다 → 새로운 개념이 추가, 수정되고 그에 따라 코드도 추가, 수정

→ 이것이 또한 단일 모델로 통합 가능해야하고 그에 맞게 코드로 구현되어야 함

⇒ 분할된 컨텍스트에서 지속적 통합이 필요한 이유

→ 자동화된 빌드 프로세스를 적용해서 테스트로 모델을 검증할 수 있다

### 컨텍스트 맵

대규모 어플리케이션의 분할된 컨텍스트들과 그들의 관계에 대한 개요를 표현한 문서. 다이어그램 혹은 문서로 쓰일 수 있다

→ 모델은 전체 시스템의 일부이기 때문에 반드시 통합되어야 하고 전체 시스템이 적절히 동작해야 한다.

→ 각 컨텍스트가 명확히 정의되지 않았다면 서로 중복되었을 확률이 높다. 컨텍스트간의 윤곽이 잡혀있지 않다면 통합시 문제가 생길 확률이 높다.

→ 프로젝트의 모든 사람이 컨텍스트 맵을 공유하고 이해해야 한다. 각 컨텍스트의 범위, 컨텍스트, 코드의 매핑 상태를 알아야 한다.

컨텍스트 맵을 만드는데 다양한 패턴이 존재 → 패턴을 활용해 컨텍스트의 명확한 역할과 관계 설명 가능

- 상호 작용 수준이 높을 때: 공유 커널, 고객-공급자 패턴,
- 독립성을 높이고 관계를 분리하고 싶을 때: 분할 방식
- 시스템과 레거시 시스템 or 외부의 어떤것과 상호작용을 다룰 때: 오픈 호스트 서비스, 변질 방지 레이어

### 공유 커널

분할된 컨텍스트를 기반으로 조직을 꾸릴 때, 서로 밀접하게 관련되어 있는 팀의 협력을 위한 컨텍스트 맵을 만드는 패턴

→ 도메인 모델의 일부는 두 팀이 공유햐애하는 부분으로 나타냄

(모델 뿐아니라 관련된 코드, DB 설계 등도 일부 포함)

→ 중복을 줄이기 위한 목적 but 분할된 컨텍스트는 유지되어야 한다

→ 명시적으로 공유된 부분은 특별한 상태를 지니며 다른 팀과 혐의하지 않고 변경해서는 안되는 공유 요소

→ 공유 커널에서 개발, 수정은 반드시 통합해야 함. 테스트 수트를 마련하고, 반드시 상대팀과 의사소통 해야함

### 고객-공급자

두 서브 시스템 한쪽이 다른 한쪽에 완전히 의존하는 특별한 관계를 표현하기 위한 패턴

→ 두 서브 시스템의 컨텍스트가 별도로 존재하고 한 쪽의 처리 결과가 다른 쪽에 반영됨

→ 공유 커널이 존재하지 않음(개념적으로, 기술적으로 불가능한 경우)

예시) 리포팅과 메시징을 포함하는 전자상거래 애플리케이션

→ 분리된 모델이 유리. 웹 쇼핑 시스템과 리포팅 시스템 간의 관계?

→ 공유 커널X. 두 모델의 개념 자체가 서로 다름

→ e-shopping 서브 시스템은 리포팅 시스템에 의존하지 않지만, 리포팅 시스템은 e-shoppoing 시스템에 의존

⇒ 고객-공급자 관계

→ 공급자 서브시스템(E-shopping)이 소비자 시스템(리포팅)에 필요한 어떤 명세를 구현해야 한다.

**고객-공급자 관계에서 개발**

양쪽 애플리케이션이 동일 DB 스키마 사용해야할 것

→ 두 팀은 의사소통할 필요가 있고, DB에 대해 같이 작업해야하고 변경 시점을 결정해야함

→ 그러나 이것이 리포팅 서브시스템에서 한계로 작용. 기다려야 하기 때문.

⇒ 두 팀이 동일 관리 체계 하에 있는 것이 아니라면, 실제 고객-공급자 관계를 구축하고 고객팀은 공급자팀에 대해 고객의 역할을 수행하라.

- 두 서브시스템의 인터페이스를 정교하게 정의
- 순응적 테스트 수트 개발
- 인터페이스 요구 사항 준수될 때마다 테스트
- 요구 사항을 위한 혐상, 예산 수립 업무 진행, 모두 이해할 수 있는 합의점과 일정 도출
- 인터페이스가 예상대로 동작하는지 확인할 수 있는 자동화된 인수테스트 함께 개발

    → 공급자 팀의 테스트 수트에 추가하고 지속적 통합의 일부가 되도록 유지

### 순응

고객-공급자 관계에서 전체 관리 주체가 없거나, 두 팀이 다른 회사인 경우에 공급자는 모델과 설계에 관심을 더디게 가지게 되고 고객을 돕는데 관심을 덜 쏟게 된다.

- 공급자 서브시스템으로부터 제공되는 이익이 문제를 안고 갈 만큼 가치가 있지 않을 경우

    → 별도의 모델을 만들어 설계하는 편이 손쉬울 수도 = 분할 방식 패턴

- 공급자 모델이 가치가 있어서 관계가 유지되어야 하는 경우

    → 공급자 팀이 모델을 변경할 때 자신을 보호하기 위한 대책이 필요하다

    → 고객팀은 두 컨텍스트를 연결하기 위한 번역 계층 구현

    → 변질 방지 레이어 사용하여 자신을 보호

- 고객이 공급자 팀의 모델을 사용해야만 하고 그것이 잘 된 모델 = 순응을 위한 경우

    공유 커널과의 차이점 = 고객팀은 커널에 변경을 가할 수 없다

### 변질 방지 레이어

레거시 소프트웨어나 분리된 애플리케이션과 상호작용이 필요한 애플리케이션을 만들어야 하는 상황

→ 많은 레거시 애플리케이션이 도메인 모델링 기법을 이용해서 만들어지지 않았고, 레거시 애플리케이션의 모델은 매우 혼란스러워서 그 모델을 이해해서 이용하며 일하기 쉽지 않다

**고객 시스템이 외부 시스템과 상호작용하는 방법**

1. 네트워크 연결 → 같은 네트워크 통신 프로토콜 사용, 클라이언트는 외부 시스템을 사용하기 위해 해당 인터페이스에 밀착
2. 데이터베이스 활용 → 외부 시스템의 데이터베이스와 동일한 데이터베이스를 사용

→ 두 경우 모두 시스템끼리 전송하는 원시 데이터를 다룸

→ 데이터의 시맨틱을 이해하기 어렵고 외부 모델에 따라 클라이언트 모델이 영향받을 수 있다

⇒ 변질 방지 레이어 사용

**변질 방지 레이어**

클라이언트 모델의 한 부분을 형성하고 동작. but 외부 모델에게 외부 모델의 언어로 전달

클라이언트 모델과 외부 모델 간의 양방향 번역자 역할

클라이언트 모델이 외부 모델에 의해 영향 받는 오염없이 순수하고 일관된 상태로 남을 수 있다는 것이 큰 장점

변질 방지 레이어를 클라이언트 모델 관점에서의 서비스의 하나로 보는 것이 좋다

→ 퍼사드 패턴, 어댑터 패턴, 트랜스레이터 활용!

### 분할 방식

- 이전의 고객-공급자, 변질 방지 레이어, 공유 커널 등은 모델과 설계를 건강하게 유지하면서 서브 시스템이 함께 동작하도록 통합하는 방법

    → 상황에 따라 노력과 절충이 필요하다.

- 통합할 때 생긱 이익보다 파생되는 문제가 크다면 분할 방식으로 진행할 수 있음

**분할 방식**

- 기업 어플리케이션을 몇 개의 어플리케이션으로 쪼개어 만들고자 할 때 사용
- 분할 방식을 사용하면 분할된 컨텍스트를 나누고, 독립적으로 모델링, 기술 선택도 자유롭

    (공통의 얇은 GUI를 공유하는 것은 모델 수준이 아닌 애플리케이션 구조와 관련된 중요도 낮은 통합)

- 분할 방식으로 진행하려면 통합된 시스템으로 돌아가지 않을 것임을 확실히 할 필요

    (통합하기 매우 어렵다. 독립적으로 개발되어 통합의 고리, 공통점이 거의 없기 때문에 가치가 없다.)

### 오픈 호스트 서비스

두 서브시스템을 통합하기 위해 일반적으로 그들 사이에 번역을 위한 레이어를 추가

→ 서브시스템이 많은 다른 시스템과 통합되어야 할 때 각 번역기를 커스터마이징하는 것은 유지보수하기 힘들

→ 외부 서브시스템을 서비스 제공자로 바라보는 것이 해결법

→ 외부 서브시스템을 서비스로 감쌀 수 있다면 모든 다른 서브시스템이 서비스를 통해서만 접근

→ 번역 레이어 필요하지 않음

→ 각 서브시스템이 외부 서브시스템과 특별한 방식으로 상호작용할 수 있기 때문에 일관성있는 서비스 세트를 만들기 위해 문제가 생길 수 있다

→ 자신의 시스템에 접근할 수 있는 프로토콜을 서비스의 집합으로 정의하라. 내 시스텝과 통합될 필요가 있는 사람이라면 누구든지 사용할 수 있도록 프로토콜을 공개하라.

### 증류

물질의 증류처럼 도메인을 증류, 정제, 지속적인 리팩터링으로 핵심과 일반 도메인을 구분하라

핵심을 설계의 중심부로 규정하고 그 경계를 명확히하라

각 도메인에 따라 같은 개념이 핵심 모델이 될 수도 있고, 서브 도메인이 될 수 있다

핵심 도메인 > 일반 모델 → 집중도, 인력 배분에 우선 순위를 따를 것

**일반적인 서브 도메인을 구현하기 위한 방법**

1. 상용 솔루션 사용
    - 학습 곡선
    - 솔루션에 대한 의존성(버그 등)
    - 통합 작업은 사내 시스템(in-house)에 비해 어렵다
2. 아웃소싱
    - 핵심 도메인에 집중하고, 다른 도메인을 다루는 짐을 놓을 수 있음
    - 통합이 불편
3. 기존 모델
    - 공개된 분석 패턴에 해당하는 책 참고
4. 사내(in-house) 개발
    - 높은 수준의 통합 가능
    - 유지 보수, 추가적인 노력

# 6장. 오늘날 DDD는 중요하다

### 에릭 에반스의 인터뷰

**Q. 왜 DDD가 오늘날 더욱 중요하다고 생각하십니까?**

DDD? 밀접하게 관계되어 있는 도메인 이슈에 집중한다는 원칙에 기반을 둔 설계 방식

1. 소프트웨어가 점점 복잡한 문제를 다루고 비지니스의 핵심을 해결하기 위해 사용된다
2. 웹 개발 플랫폼이 DDD를 생산적으로 적용하기 적합할 만큼 성숙했고 긍정적인 트렌드도 등장했다
3. 애자일 프로세스가 영향력이 있기 때문에 사람들이 비지니스 파트너와 밀접하게 일하기, 지속적 통합, 수준 높은 의사 소통을 적용한다

→ 도메인이 점점 중요해지고, DDD를 적용하기 위한 기반이 마련되었다

**Q. 기술 플랫폼(자바, .Net, 루비 등)은 계속 진화하고 있습니다. DDD는 여기에 어떻게 적응할 수 있다고 생각하십니까?**

흠냐?

**Q. 당신이 책을 쓴 이후에 DDD 커뮤니티에서는 어떠한 일이 일어나고 있습니까?**

전략적 설계, 컨텍스트 매핑 결과를 상용 소프트웨어 구매 vs 자체 개발 여부 평가 시 활용, DSLs 연구 등 다양한 분야에서 적용됨

**Q. 오늘날 DDD를 배우려고 노력하는 사람들에게 해 주고 싶은 조언이 있나요?**

책을 읽고 적용해보라!

**기억 할 것**

1. 도메인은 단순한 상태로 유지! 모델러도 코드를 작성해야 합니다
2. 구체적인 시나리오에 초점. 추상적인 생각은 실제 사례에 연결되어야 함
3. DDD를 모든 것에 적용하려 하지 말라. 컨택스트 맵을 그리고 적용할 부분, 하지 않을 부분 정한 후 집중
4. 실험하고 실수를 많이 하세요! 모델링은 창조적인 작업입니다~!